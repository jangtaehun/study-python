클래스 - 반, 모든 클래스는 추상적이다.
    공통 요소가 모여 있는 곳
    공통 요소를 한 번만 선언하자
    ❤️추상적, 공통 요소가 모여 있다. 접근할 수 있는 구체화된 무엇인가에 접근 = 객체 -> 객체화

    1. 타입이다.
        클래스 안에 선언된 변수와 메소드를 사용하고 싶다면,
        해당 클래스 타입으로 변수를 선언해야 한다.

    2. 주어이다.
        원숭이가 바나나를 먹는다.
        Monkey.eat("바나나")
        문장의 맨 앞에 등장하므로 앞글자를 대문자로 작성한다.


객체 = 서로 다른 많은 데이터를 하나로 묶어서 표현한 것
    instance variable
    클래스는 추상적인 개념이고 이 추상적인 개념을 실체화(구체화)시켜야지만 사용할 수 있다. 따라서 추상적인 개념을 실체화(구체화)시켜놓은 것을 객체
    [클래스]   [객체]
    자동차     엄마차
    도형       세모

객체화 instance
    추상적인 개념을 구체화 시키는 작업
    객체명 = 클래스명()

클래스 선언
    class 클래스명:
        필드(변수, 메소드)

클래스의 필드 사용
    1. 객체화(instance)
        객체(instance variable)를 만드는 작업.
        추상적인 개념을 구체화시키는 작업.

    2.


생성자
    클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 기능이 똑같지만 메소드라고 부르지 않는다.
    생성자는 메모리에 할당한 필드의 주소를 리턴하기 떄문에,
    선언 시, 리턴이라는 기능을 사용할 수 없다.
    클래스에 있는 필드를 메모리에 할당해 주고 그 필드의 주소값을 가지고 돌아와야 하기 때문에 개발자가 직접 리턴값을 작성하면 안된다.
    1. 해당 필드를 메모리에 할당하고 할당된 필드의 주소값을 가져온다.
    2. 초기화

기본 생성자
    매개변수가 없는 생성자를 뜻하며, 클래스 선언 시 자동으로 선언된다.
    사용자가 직접 생성자를 선언하게 되면 자동으로 선언되지 않는다.

self
    필드에 접근한 객체가 누구인지 알아야 해당 필드에 접근할 수 있다.
    이때 접근한 객체가 가지고 있는 필드의 주소값이 self라는 변수에 자동으로 담긴다.


객체도 값으로 본다
static method: self를 쓰지 않을 때, 한 번에 모든 객체에 적용할 기능
class method: wrapping, 기존 생성자에 추가할 기능을 작성한다.
private

상속
    1. 기존 것을 그대로 가져다 쓰자
    2. 추상화

생성자
    부모 생성자부터 호출된다.
    기본 생성자는 자동으로 부모 생성자를 호출하지만,
    직접 생성자를 자식에서 선언하면 부모 생성자도 직접 호출한다.

재정의(Overriding)
    부모꺼 맘에 안들어서 자식에서 같은 이름으로 다시 구현
    부모꺼를 super()로 불러서 사용 가능